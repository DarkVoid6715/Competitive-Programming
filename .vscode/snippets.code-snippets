{
    "Template": {
        "prefix": "cp_template",
        "body": [
            "#pragma GCC optimize(\"unroll-loops, O3\")\r",
            "#include <bits/stdc++.h>\r",
            "#include <ext/pb_ds/tree_policy.hpp>\r",
            "#include <ext/pb_ds/assoc_container.hpp>\r",
            "using namespace std;\r",
            "using namespace __gnu_pbds;\r",
            "using ll = long long;\r",
            "using ld = long double;\r",
            "template <class T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\r",
            "const int xx[8] = { -1, 0, 1, 0, -1, -1, 1, 1 };\r",
            "const int yy[8] = { 0, -1, 0, 1, -1, 1, -1, 1 };\r",
            "\r",
            "int main() {\r",
            "    ios_base::sync_with_stdio(false);\r",
            "    cin.tie(NULL), srand(time(NULL));\r",
            "    \r",
            "    return 0;\r",
            "}"
        ],
        "description": ""
    },
	"Google Code Jam Template": {
        "prefix": "cp_google_code_jam_template",
        "body": [
            "#pragma GCC optimize(\"unroll-loops, O3\")\r",
            "#include <bits/stdc++.h>\r",
            "#include <ext/pb_ds/tree_policy.hpp>\r",
            "#include <ext/pb_ds/assoc_container.hpp>\r",
            "using namespace std;\r",
            "using namespace __gnu_pbds;\r",
            "using ll = long long;\r",
            "using ld = long double;\r",
            "template <class T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\r",
            "const int xx[8] = { -1, 0, 1, 0, -1, -1, 1, 1 };\r",
            "const int yy[8] = { 0, -1, 0, 1, -1, 1, -1, 1 };\r",
            "\r",
            "void solve() {\r",
            "\r",
            "}\r",
            "\r",
            "int main() {\r",
            "    ios_base::sync_with_stdio(false);\r",
            "    cin.tie(NULL), srand(time(NULL));\r",
            "    int t;\r",
            "    cin >> t;\r",
            "    for (int i = 1; i <= t; i++) {\r",
            "        cout << \"Case #\" << i << \": \";\r",
            "        solve();\r",
            "    }\r",
            "    return 0;\r",
            "}"
        ],
        "description": ""
    },
    "Constructive Tester Template": {
        "prefix": "cp_constructive_template_tester",
        "body": [
            "#pragma GCC optimize(\"unroll-loops, O3\")\r",
            "#include <bits/stdc++.h>\r",
            "#include <ext/pb_ds/tree_policy.hpp>\r",
            "#include <ext/pb_ds/assoc_container.hpp>\r",
            "using namespace std;\r",
            "using namespace __gnu_pbds;\r",
            "using ll = long long;\r",
            "using ld = long double;\r",
            "template <class T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\r",
            "const int xx[8] = { -1, 0, 1, 0, -1, -1, 1, 1 };\r",
            "const int yy[8] = { 0, -1, 0, 1, -1, 1, -1, 1 };\r",
            "string file_name = \"code\";\r",
            "\r",
            "int main() {\r",
            "    ios_base::sync_with_stdio(false);\r",
            "    cin.tie(NULL), srand(time(NULL));\r",
            "    ifstream in(\"input.txt\");\r",
            "    ifstream out(file_name + \"_output.txt\");\r",
            "    \r",
            "    return 0;\r",
            "}"
        ],
        "description": ""
    },
    "Modular Arithmetic Class": {
        "prefix": "cp_modular_arithmetic_class",
        "body": [
            "struct modular_arithmetic {\r",
            "    const int m = 1e9 + 7; //const int m = 998244353;\r",
            "    int add(ll x, ll y) {\r",
            "        return ((x % m + m) % m + (y % m + m) % m) % m;\r",
            "    }\r",
            "    int sub(ll x, ll y) {\r",
            "        return (((x % m + m) % m - (y % m + m) % m) % m + m) % m;\r",
            "    }\r",
            "    int mult(ll x, ll y) {\r",
            "        return (((x % m + m) % m) * ((y % m + m) % m)) % m;\r",
            "    }\r",
            "    int pow(ll x, ll y) {\r",
            "        if (!y) return 1 % m;\r",
            "        ll ans = pow(x, y / 2);\r",
            "        ans = (ans * ans) % m;\r",
            "        if (y % 2) ans = (ans * (x % m)) % m;\r",
            "        return ans;\r",
            "    }\r",
            "    int inv(ll x) {\r",
            "        return pwr(x, m - 2);\r",
            "    }\r",
            "    int div(ll x, ll y) {\r",
            "        return ((x % m) * inv(y)) % m;\r",
            "    }\r",
            "\r",
            "};\r",
            "modular_arithmetic mod;"
        ],
        "description": ""
    },
    "Union Find": {
        "prefix": "cp_union_find",
        "body": [
            "struct union_find {\r",
            "    vector<int> par;\r",
            "    int cnt;\r",
            "    void init(int n) { par.resize(n + 1, -1), cnt = n; }\r",
            "    int size(int x) { return -par[find(x)]; }\r",
            "    int find(int x) {\r",
            "        return (par[x] < 0) ? x : par[x] = find(par[x]);\r",
            "    }\r",
            "    bool same(int x, int y) { return find(x) == find(y); }\r",
            "    bool unite(int x, int y) {\r",
            "        x = find(x), y = find(y);\r",
            "        if (x == y) return false;\r",
            "        if (size(x) < size(y)) swap(x, y);\r",
            "        par[x] += par[y], par[y] = x, cnt--;\r",
            "        return true;\r",
            "    }\r",
            "};"
        ],
        "description": ""
    },
    "Fenwick Tree": {
        "prefix": "cp_fenwick_tree",
        "body": [
            "template <class T> struct fenwick_tree {\r",
            "    vector<T> arr;\r",
            "    void init(int n) { arr = vector<int>(n + 1, 0); }\r",
            "    void update(int pos, T add) {\r",
            "        for (; pos < (int)arr.size(); pos |= pos + 1)\r",
            "            arr[pos] += add;\r",
            "    }\r",
            "    T query(int pos) {\r",
            "        T sum = 0;\r",
            "        for (; pos >= 0; pos = (pos & (pos + 1)) - 1)\r",
            "            sum += arr[pos];\r",
            "        return sum;\r",
            "    }\r",
            "};"
        ],
        "description": ""
    },
    "Sieve of Eratosthenes": {
        "prefix": "cp_sieve_of_eratosthenes",
        "body": [
            "struct sieve_of_eratosthenes {\r",
            "    vector<bool> arr;\r",
            "    void init(int n) {\r",
            "        arr = vector<bool>(n + 1, true);\r",
            "        arr[0] = arr[1] = false;\r",
            "        for(int i = 2; i <= n; i++)\r",
            "            if(arr[i] && (ll)i * i <= n)\r",
            "                for(int j = i * i; j <= n; j += i) arr[j] = false;\r",
            "    }\r",
            "    bool query(int x) { return arr[x]; }\r",
            "};"
        ],
        "description": ""
    },
    "Factorials Class": {
        "prefix": "cp_factorials_class",
        "body": [
            "struct factorials_class {\r",
            "    vector<int> fac, inv;\r",
            "    void init(int n) {\r",
            "        fac = vector<int>(n + 1);\r",
            "        inv = vector<int>(n + 1);\r",
            "        fac[0] = inv[0] = 1;\r",
            "        for (int i = 1; i <= n; i++) {\r",
            "            fac[i] = mod.mul(fac[i - 1], i);\r",
            "            inv[i] = mod.inv(fac[i]);\r",
            "        }\r",
            "    }\r",
            "    int query(int x) { return fac[x]; }\r",
            "    int prm(int x, int y) {\r",
            "        if (y > x) return 0;\r",
            "        return mod.mul(fac[x], inv[x - y]);\r",
            "    }\r",
            "    int cmb(int x, int y) {\r",
            "        if (y > x) return 0;\r",
            "        return mod.mul(prm(x, y), inv[y]);\r",
            "    }\r",
            "};"
        ],
        "description": ""
    }
}