{
    "Template": {
        "prefix": "cp_template",
        "body": [
            "#pragma GCC optimize(\"unroll-loops, O3\")\r",
            "#include <bits/stdc++.h>\r",
            "#include <ext/pb_ds/tree_policy.hpp>\r",
            "#include <ext/pb_ds/assoc_container.hpp>\r",
            "using namespace std;\r",
            "using namespace __gnu_pbds;\r",
            "using ll = long long;\r",
            "using ld = long double;\r",
            "const int xx[8] = { -1, 0, 1, 0, -1, -1, 1, 1 };\r",
            "const int yy[8] = { 0, -1, 0, 1, -1, 1, -1, 1 };\r",
            "\r",
            "int main() {\r",
            "    ios_base::sync_with_stdio(false);\r",
            "    cin.tie(NULL), srand(time(NULL));\r",
            "    \r",
            "    return 0;\r",
            "}"
        ],
        "description": ""
    },
	"Google Code Jam Template": {
        "prefix": "cp_google_code_jam_template",
        "body": [
            "#pragma GCC optimize(\"unroll-loops, O3\")\r",
            "#include <bits/stdc++.h>\r",
            "#include <ext/pb_ds/tree_policy.hpp>\r",
            "#include <ext/pb_ds/assoc_container.hpp>\r",
            "using namespace std;\r",
            "using namespace __gnu_pbds;\r",
            "using ll = long long;\r",
            "using ld = long double;\r",
            "const int xx[8] = { -1, 0, 1, 0, -1, -1, 1, 1 };\r",
            "const int yy[8] = { 0, -1, 0, 1, -1, 1, -1, 1 };\r",
            "\r",
            "void solve() {\r",
            "\r",
            "}\r",
            "\r",
            "int main() {\r",
            "    ios_base::sync_with_stdio(false);\r",
            "    cin.tie(NULL), srand(time(NULL));\r",
            "    int t;\r",
            "    cin >> t;\r",
            "    for (int i = 1; i <= t; i++) {\r",
            "        cout << \"Case #\" << i << \": \";\r",
            "        solve();\r",
            "    }\r",
            "    return 0;\r",
            "}"
        ],
        "description": ""
    },
    "Constructive Tester Template": {
        "prefix": "cp_constructive_tester_template",
        "body": [
            "#pragma GCC optimize(\"unroll-loops, O3\")\r",
            "#include <bits/stdc++.h>\r",
            "#include <ext/pb_ds/tree_policy.hpp>\r",
            "#include <ext/pb_ds/assoc_container.hpp>\r",
            "using namespace std;\r",
            "using namespace __gnu_pbds;\r",
            "using ll = long long;\r",
            "using ld = long double;\r",
            "const int xx[8] = { -1, 0, 1, 0, -1, -1, 1, 1 };\r",
            "const int yy[8] = { 0, -1, 0, 1, -1, 1, -1, 1 };\r",
            "\r",
            "int main() {\r",
            "    ios_base::sync_with_stdio(false);\r",
            "    cin.tie(NULL), srand(time(NULL));\r",
            "    ifstream in(\"input.txt\");\r",
            "    ifstream out(\"code_output.txt\");\r",
            "    \r",
            "    return 0;\r",
            "}"
        ],
        "description": ""
    },
    "Modular Arithmetic Class": {
        "prefix": "cp_modular_arithmetic",
        "body": [
            "struct modular_arithmetic {\r",
            "    const int mod = 1e9 + 7; //const int mod = 998244353;\r",
            "    int add(ll x, ll y) {\r",
            "        return ((x % mod + mod) % mod + (y % mod + mod) % mod) % mod;\r",
            "    }\r",
            "    int sub(ll x, ll y) {\r",
            "        return ((x % mod + mod) % mod - (y % mod + mod) % mod) % mod;\r",
            "    }\r",
            "    int mult(ll x, ll y) {\r",
            "        return (((x % mod + mod) % mod) * ((y % mod + mod) % mod)) % mod;\r",
            "    }\r",
            "    int pwr(ll x, ll y) {\r",
            "        if (!y) return 1 % mod;\r",
            "        ll ans = pwr(x, y / 2);\r",
            "        ans = (ans * ans) % mod;\r",
            "        if (y % 2) ans = (ans * (x % mod)) % mod;\r",
            "        return ans;\r",
            "    }\r",
            "    int inv(ll x) {\r",
            "        return pwr(x, mod - 2);\r",
            "    }\r",
            "    int div(ll x, ll y) {\r",
            "        return ((x % mod) * inv(y)) % mod;\r",
            "    }\r",
            "};\r",
            "modular_arithmetic mod;"
        ],
        "description": ""
    },
    "Union Find": {
        "prefix": "cp_union_find",
        "body": [
            "struct union_find {\r",
            "    vector<int> par;\r",
            "    void init(int n) { par.resize(n, -1); }\r",
            "    int size(int x) { return -par[find(x)]; }\r",
            "    int find(int x) {\r",
            "        return (par[x] < 0) ? x : par[x] = find(par[x]);\r",
            "    }\r",
            "    bool unite(int a, int b) {\r",
            "        a = find(a), b = find(b);\r",
            "        if (a == b) return false;\r",
            "        if (size(a) < size(b)) swap(a, b);\r",
            "        par[a] += par[b], par[b] = a;\r",
            "        return true;\r",
            "    }\r",
            "};"
        ],
        "description": ""
    },
    "Fenwick Tree": {
        "prefix": "cp_fenwick_tree",
        "body": [
            "template <class T> struct fenwick_tree {\r",
            "    vector<T> arr;\r",
            "    void init(int n) { arr = vector<int>(n + 1, 0); }\r",
            "    void update(int pos, T add) {\r",
            "        for (; pos < (int)arr.size(); pos |= pos + 1)\r",
            "            arr[pos] += add;\r",
            "    }\r",
            "    T query(int pos) {\r",
            "        T sum = 0;\r",
            "        for (; pos >= 0; pos = (pos & (pos + 1)) - 1)\r",
            "            sum += arr[pos];\r",
            "        return sum;\r",
            "    }\r",
            "};"
        ],
        "description": ""
    }
}