{
    "Template": {
        "prefix": "cp_template",
        "body": [
            "#pragma GCC optimize(\"unroll-loops, O3\")\r",
            "#include <bits/stdc++.h>\r",
            "#include <ext/pb_ds/tree_policy.hpp>\r",
            "#include <ext/pb_ds/assoc_container.hpp>\r",
            "using namespace std;\r",
            "using namespace __gnu_pbds;\r",
            "using ll = long long;\r",
            "using ld = long double;\r",
            "template <class T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\r",
            "const int xx[8] = { -1, 0, 1, 0, -1, -1, 1, 1 };\r",
            "const int yy[8] = { 0, -1, 0, 1, -1, 1, -1, 1 };\r",
            "const ld pi = atan(1) * 4;\r",
            "\r",
            "int main() {\r",
            "    ios_base::sync_with_stdio(false);\r",
            "    cin.tie(NULL), srand(time(NULL));\r",
            "    \r",
            "    return 0;\r",
            "}"
        ],
        "description": ""
    },
    "Multiple Testcases Template": {
        "prefix": "cp_multiple_testcases_template",
        "body": [
            "#pragma GCC optimize(\"unroll-loops, O3\")\r",
            "#include <bits/stdc++.h>\r",
            "#include <ext/pb_ds/tree_policy.hpp>\r",
            "#include <ext/pb_ds/assoc_container.hpp>\r",
            "using namespace std;\r",
            "using namespace __gnu_pbds;\r",
            "using ll = long long;\r",
            "using ld = long double;\r",
            "template <class T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\r",
            "const int xx[8] = { -1, 0, 1, 0, -1, -1, 1, 1 };\r",
            "const int yy[8] = { 0, -1, 0, 1, -1, 1, -1, 1 };\r",
            "const ld pi = atan(1) * 4;\r",
            "\r",
            "void solve() {\r",
            "\r",
            "}\r",
            "\r",
            "int main() {\r",
            "    ios_base::sync_with_stdio(false);\r",
            "    cin.tie(NULL), srand(time(NULL));\r",
            "    int t;\r",
            "    cin >> t;\r",
            "    while (t--) solve();\r",
            "    return 0;\r",
            "}"
        ],
        "description": ""
    },
	"Google Code Jam Template": {
        "prefix": "cp_google_code_jam_template",
        "body": [
            "#pragma GCC optimize(\"unroll-loops, O3\")\r",
            "#include <bits/stdc++.h>\r",
            "#include <ext/pb_ds/tree_policy.hpp>\r",
            "#include <ext/pb_ds/assoc_container.hpp>\r",
            "using namespace std;\r",
            "using namespace __gnu_pbds;\r",
            "using ll = long long;\r",
            "using ld = long double;\r",
            "template <class T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\r",
            "const int xx[8] = { -1, 0, 1, 0, -1, -1, 1, 1 };\r",
            "const int yy[8] = { 0, -1, 0, 1, -1, 1, -1, 1 };\r",
            "const ld pi = atan(1) * 4;\r",
            "\r",
            "void solve() {\r",
            "\r",
            "}\r",
            "\r",
            "int main() {\r",
            "    ios_base::sync_with_stdio(false);\r",
            "    cin.tie(NULL), srand(time(NULL));\r",
            "    int t;\r",
            "    cin >> t;\r",
            "    for (int i = 1; i <= t; i++) {\r",
            "        cout << \"Case #\" << i << \": \";\r",
            "        solve();\r",
            "    }\r",
            "    return 0;\r",
            "}"
        ],
        "description": ""
    },
    "Constructive Tester Template": {
        "prefix": "cp_constructive_template_tester",
        "body": [
            "#pragma GCC optimize(\"unroll-loops, O3\")\r",
            "#include <bits/stdc++.h>\r",
            "#include <ext/pb_ds/tree_policy.hpp>\r",
            "#include <ext/pb_ds/assoc_container.hpp>\r",
            "using namespace std;\r",
            "using namespace __gnu_pbds;\r",
            "using ll = long long;\r",
            "using ld = long double;\r",
            "template <class T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\r",
            "const int xx[8] = { -1, 0, 1, 0, -1, -1, 1, 1 };\r",
            "const int yy[8] = { 0, -1, 0, 1, -1, 1, -1, 1 };\r",
            "string file_name = \"code\";\r",
            "\r",
            "int main() {\r",
            "    ios_base::sync_with_stdio(false);\r",
            "    cin.tie(NULL), srand(time(NULL));\r",
            "    ifstream in(\"input.txt\");\r",
            "    ifstream out(file_name + \"_output.txt\");\r",
            "    \r",
            "    return 0;\r",
            "}"
        ],
        "description": ""
    },
    "Modular Arithmetic Class": {
        "prefix": "cp_modular_arithmetic",
        "body": [
            "struct modular_arithmetic {\r",
            "    const int m = 1e9 + 7; //const int m = 998244353;\r",
            "    int add(ll x, ll y) {\r",
            "        return ((x % m + m) % m + (y % m + m) % m) % m;\r",
            "    }\r",
            "    int sub(ll x, ll y) {\r",
            "        return (((x % m + m) % m - (y % m + m) % m) % m + m) % m;\r",
            "    }\r",
            "    int mult(ll x, ll y) {\r",
            "        return (((x % m + m) % m) * ((y % m + m) % m)) % m;\r",
            "    }\r",
            "    int pow(ll x, ll y) {\r",
            "        if (!y) return 1 % m;\r",
            "        ll ans = pow(x, y / 2);\r",
            "        ans = (ans * ans) % m;\r",
            "        if (y % 2) ans = (ans * (x % m)) % m;\r",
            "        return ans;\r",
            "    }\r",
            "    int inv(ll x) {\r",
            "        return pwr(x, m - 2);\r",
            "    }\r",
            "    int div(ll x, ll y) {\r",
            "        return ((x % m) * inv(y)) % m;\r",
            "    }\r",
            "\r",
            "};\r",
            "modular_arithmetic mod;"
        ],
        "description": ""
    },
    "Union Find": {
        "prefix": "cp_union_find",
        "body": [
            "struct union_find {\r",
            "    vector<int> par;\r",
            "    int cnt;\r",
            "    void init(int n) { par.resize(n + 1, -1), cnt = n; }\r",
            "    int size(int x) { return -par[find(x)]; }\r",
            "    int find(int x) {\r",
            "        return (par[x] < 0) ? x : par[x] = find(par[x]);\r",
            "    }\r",
            "    bool same(int x, int y) { return find(x) == find(y); }\r",
            "    bool unite(int x, int y) {\r",
            "        x = find(x), y = find(y);\r",
            "        if (x == y) return false;\r",
            "        if (size(x) < size(y)) swap(x, y);\r",
            "        par[x] += par[y], par[y] = x, cnt--;\r",
            "        return true;\r",
            "    }\r",
            "};"
        ],
        "description": ""
    },
    "Fenwick Tree": {
        "prefix": "cp_fenwick_tree",
        "body": [
            "template <class T> struct fenwick_tree {\r",
            "    vector<T> arr;\r",
            "    void init(int n) { arr = vector<int>(n + 1, 0); }\r",
            "    void update(int pos, T add) {\r",
            "        for (; pos < (int)arr.size(); pos |= pos + 1)\r",
            "            arr[pos] += add;\r",
            "    }\r",
            "    T query(int pos) {\r",
            "        T sum = 0;\r",
            "        for (; pos >= 0; pos = (pos & (pos + 1)) - 1)\r",
            "            sum += arr[pos];\r",
            "        return sum;\r",
            "    }\r",
            "};"
        ],
        "description": ""
    },
    "Sieve of Eratosthenes": {
        "prefix": "cp_sieve_of_eratosthenes",
        "body": [
            "struct sieve_of_eratosthenes {\r",
            "    vector<bool> arr;\r",
            "    void init(int n) {\r",
            "        arr = vector<bool>(n + 1, true);\r",
            "        arr[0] = arr[1] = false;\r",
            "        for(int i = 2; i <= n; i++)\r",
            "            if(arr[i] && (ll)i * i <= n)\r",
            "                for(int j = i * i; j <= n; j += i) arr[j] = false;\r",
            "    }\r",
            "    bool query(int x) { return arr[x]; }\r",
            "};"
        ],
        "description": ""
    },
    "Factorials Class": {
        "prefix": "cp_factorials",
        "body": [
            "struct factorials {\r",
            "    vector<int> fac, inv;\r",
            "    void init(int n) {\r",
            "        fac = vector<int>(n + 1);\r",
            "        inv = vector<int>(n + 1);\r",
            "        fac[0] = inv[0] = 1;\r",
            "        for (int i = 1; i <= n; i++) {\r",
            "            fac[i] = mod.mul(fac[i - 1], i);\r",
            "            inv[i] = mod.inv(fac[i]);\r",
            "        }\r",
            "    }\r",
            "    int query(int x) { return fac[x]; }\r",
            "    int prm(int x, int y) {\r",
            "        if (y > x) return 0;\r",
            "        return mod.mul(fac[x], inv[x - y]);\r",
            "    }\r",
            "    int cmb(int x, int y) {\r",
            "        if (y > x) return 0;\r",
            "        return mod.mul(prm(x, y), inv[y]);\r",
            "    }\r",
            "};"
        ],
        "description": ""
    },
    "Dijkstra's Algorithm": {
        "prefix": "cp_dijkstra",
        "body": [
            "template<class T> struct dijkstra {\r",
            "    vector<vector<pair<int, T>>> adj;\r",
            "    vector<T> dst;\r",
            "    vector<int> pre;\r",
            "    void init(int n, vector<pair<int, T>> inp[]) {\r",
            "        adj = vector<vector<pair<int, T>>>(n + 1, vector<pair<int, T>>());\r",
            "        for (int i = 1; i <= n; i++) adj[i] = inp[i];\r",
            "    }\r",
            "    void init(vector<vector<pair<int, T>>> &inp) { adj = inp; }\r",
            "    void getPaths(int src) {\r",
            "        dst = vector<T>(adj.size(), -1);\r",
            "        pre = vector<int>(adj.size());\r",
            "        set<pair<T, int>> que;\r",
            "        que.emplace(0, src);\r",
            "        dst[src] = 0;\r",
            "        while (!que.empty()) {\r",
            "            int vtx = que.begin()->second;\r",
            "            que.erase(que.begin());\r",
            "            for (auto &i : adj[vtx])\r",
            "                if (dst[i.first] == -1 || dst[i.first] > dst[vtx] + i.second) {\r",
            "                    que.erase({ dst[i.first], i.first });\r",
            "                    dst[i.first] = dst[vtx] + i.second;\r",
            "                    pre[i.first] = vtx;\r",
            "                    que.emplace(dst[i.first], i.first);\r",
            "                }\r",
            "        }\r",
            "    }\r",
            "};"
        ],
        "description": ""
    },
    "Sparse Table": {
        "prefix": "cp_sparse_table",
        "body": [
            "template<class T> struct sparse_table {\r",
            "    vector<vector<T>> jmp;\r",
            "    void init(int n, T a[]) {\r",
            "        vector<T> arr(n);\r",
            "        for (int i = 0; i < n; i++) arr[i] = a[i];\r",
            "        init(arr);\r",
            "    }\r",
            "    void init(vector<T> &arr){\r",
            "        int n = (int)arr.size(), dpt = 32 - __builtin_clz(n);\r",
            "        jmp = vector<vector<T>>(dpt, arr);\r",
            "        for(int i = 0; i < dpt - 1; i++)\r",
            "            for(int j = 0; j < n; j++)\r",
            "                jmp[i + 1][j] = min(jmp[i][j], jmp[i][min(j + (1 << i), n - 1)]);\r",
            "    }\r",
            "    T query(int l, int r) {\r",
            "        int dpt = 31 - __builtin_clz(r - l + 1);\r",
            "        return min(jmp[dpt][l], jmp[dpt][r - (1 << dpt) + 1]);\r",
            "    }\r",
            "};"
        ],
        "description": ""
    },
    "Matrix Operations Class": {
        "prefix": "cp_matrix_operations",
        "body": [
            "struct matrix_operations {\r",
            "    vector<vector<ll>> add(vector<vector<ll>> a, vector<vector<ll>> b) {\r",
            "        vector<vector<ll>> res(a.size(), vector<ll>(a[0].size()));\r",
            "        for (int i = 0; i < (int)a.size(); i++)\r",
            "            for (int j = 0; j < (int)a[0].size(); j++)\r",
            "                res[i][j] = a[i][j] + b[i][j];\r",
            "        return res;\r",
            "    }\r",
            "    vector<vector<ll>> sub(vector<vector<ll>> a, vector<vector<ll>> b) {\r",
            "        vector<vector<ll>> res(a.size(), vector<ll>(a[0].size()));\r",
            "        for (int i = 0; i < (int)a.size(); i++)\r",
            "            for (int j = 0; j < (int)a[0].size(); j++)\r",
            "                res[i][j] = a[i][j] - b[i][j];\r",
            "        return res;\r",
            "    }\r",
            "    vector<vector<ll>> mul(vector<vector<ll>> a, vector<vector<ll>> b) {\r",
            "        vector<vector<ll>> res(a.size(), vector<ll>(b[0].size()));\r",
            "        for (int i = 0; i < (int)a.size(); i++)\r",
            "            for (int j = 0; j < (int)b[0].size(); j++)\r",
            "                for (int k = 0; k < (int)a[0].size(); k++)\r",
            "                    res[i][j] += a[i][k] * b[k][j];\r",
            "        return res;\r",
            "    }\r",
            "    vector<vector<ll>> identity(int n) {\r",
            "        vector<vector<ll>> res(n, vector<ll>(n));\r",
            "        for (int i = 0; i < n; i++) res[i][i] = 1;\r",
            "        return res;\r",
            "    }\r",
            "    vector<vector<ll>> pow(vector<vector<ll>> x, ll n) {\r",
            "        if (!n) return identity(x.size());\r",
            "        vector<vector<ll>> res = pow(x, n / 2);\r",
            "        res = mul(res, res);\r",
            "        if (n % 2) res = mul(res, x);\r",
            "        return res;\r",
            "    }\r",
            "};"
        ],
        "description": ""
    },
    "Segment Tree": {
        "prefix": "cp_segment_tree",
        "body": [
            "template <class T> struct segment_tree {\r",
            "    vector<T> arr;\r",
            "    int n;\r",
            "    void init(int an) { n = an, arr = vector<T>(4 * n + 1); }\r",
            "    void init(vector<T> &a) {\r",
            "        n = a.size(), arr = vector<T>(4 * n + 1);\r",
            "        build(1, 0, n - 1, a);\r",
            "    }\r",
            "    void init(int an, T a[]) {\r",
            "        n = an, arr = vector<T>(4 * n + 1);\r",
            "        vector<T> av(n);\r",
            "        for (int i = 0; i < n; i++) av[i] = a[i];\r",
            "        build(1, 0, n - 1, av);\r",
            "    }\r",
            "    void build(int vtx, int l, int r, vector<T> &a) {\r",
            "        if (l == r) arr[vtx] = a[l];\r",
            "        else {\r",
            "            int mid = l + (r - l) / 2;\r",
            "            build(vtx * 2, l, mid, a);\r",
            "            build(vtx * 2 + 1, mid + 1, r, a);\r",
            "            arr[vtx] = arr[vtx * 2] + arr[vtx * 2 + 1];\r",
            "        }\r",
            "    }\r",
            "    T query(int vtx, int l, int r, int gl, int gr) {\r",
            "        if (l > gr || r < gl) return 0;\r",
            "        else if (l == gl && r == gr) return arr[vtx];\r",
            "        else {\r",
            "            int mid = l + (r - l) / 2;\r",
            "            T r1 = query(vtx * 2, l, mid, gl, min(gr, mid));\r",
            "            T r2 = query(vtx * 2 + 1, mid + 1, r, max(gl, mid + 1), gr);\r",
            "            return r1 + r2;\r",
            "        }\r",
            "    }\r",
            "    T query(int l, int r) {\r",
            "        return query(1, 0, n - 1, l, r);\r",
            "    }\r",
            "    void update(int vtx, int l, int r, int idx, T val) {\r",
            "        if (l == idx && r == idx) arr[vtx] = val;\r",
            "        else {\r",
            "            int mid = l + (r - l) / 2;\r",
            "            if (idx <= mid) update(vtx * 2, l, mid, idx, val);\r",
            "            else update(vtx * 2 + 1, mid + 1, r, idx, val);\r",
            "            arr[vtx] = arr[vtx * 2] + arr[vtx * 2 + 1];\r",
            "        }\r",
            "    }\r",
            "    void update(int idx, T val) {\r",
            "        update(1, 0, n - 1, idx, val);\r",
            "    }\r",
            "};"
        ],
        "description": ""
    },
    "Knuth-Morris-Pratt Algorithm": {
        "prefix": "cp_kmp",
        "body": [
            "vector<bool> kmp(string s, string t) {\r",
            "    int n = s.length();\r",
            "    int m = t.length();\r",
            "    if (!n || !m || m > n) return vector(n);\r",
            "    vector<int> pat(m);\r",
            "    pat[0] = 0;\r",
            "    int i = 1, j = 0;\r",
            "    while (i < m) {\r",
            "        if (t[i] == t[j]) pat[i++] = ++j;\r",
            "        else if (j > 0) j = pat[j - 1];\r",
            "        else i++;\r",
            "    }\r",
            "    vector<bool> ex(n);\r",
            "    i = 0, j = 0;\r",
            "    while (i < n) {\r",
            "        if (s[i] == t[j]) {\r",
            "            j++;\r",
            "            if (j >= m) ex[i - m + 1] = true, j = pat[j - 1];\r",
            "            i++;\r",
            "        } else if (j > 0) j = pat[j - 1];\r",
            "        else i++;\r",
            "    }\r",
            "    return ex;\r",
            "}"
        ],
        "description": ""
    },
    "Binary Search": {
        "prefix": "cp_binary_search",
        "body": [
            "template<class T>\r",
            "T binary_search(vector<T> &arr, T val) {\r",
            "    int n = arr.size();\r",
            "    T l = 0, r = n - 1;\r",
            "    while (l < r) {\r",
            "        int mid = l + (r - l) / 2;\r",
            "        if (val <= arr[mid]) r = mid;\r",
            "        else l = mid + 1;\r",
            "    }\r",
            "    return (a[l] == val) ? l : -1;\r",
            "}"
        ],
        "description": ""
    },
    "Mo's Algorithm": {
        "prefix": "cp_mo",
        "body": [
            "template<typename T>",
            "vector<T> mo(vector<pair<int, int>> que, function<T(int)> solve, function<void(int)> add, function<void(int)> sub) {",
            "    constexpr int BS = 500; // Change if you want to optimize runtime",
            "    vector<pair<pair<int, int>, int>> qord;",
            "    for (int i = 0; i < (int)que.size(); i++)",
            "        qord.emplace_back(que[i], i);",
            "    sort(qord.begin(), qord.end(), [](const pair<pair<int, int>, int> &a, const pair<pair<int, int>, int> &b) {",
            "        return make_pair(a.first.first / BS, a.first.second) < make_pair(b.first.first / BS, b.first.second);",
            "    });",
            "    vector<T> res(que.size());",
            "    int l = 0, r = -1;",
            "    for (const pair<pair<int, int>, int> &q : qord) {",
            "        while (q.first.first > l) sub(l++);",
            "        while (q.first.first < l) add(--l);",
            "        while (q.first.second > r) add(++r);",
            "        while (q.first.second < r) sub(r--);",
            "        res[q.second] = solve(q.second);",
            "    }",
            "    return res;",
            "}"
        ],
        "description": ""
    }
}